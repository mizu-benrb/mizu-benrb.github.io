---
layout: essay
type: essay
title: "3 Topics, 1 Class, 4 Takeaways: A reflection on software engineering"
# All dates must be YYYY-MM-DD format!
date: 2024-05-29
published: true
labels:
  - Software Engineering
  - Configuration Management
  - Functional Programming
  - Software Ethics
---

<img width="300px" class="rounded float-start pe-4" src="../img/software-engineering-reflection/software-engineering-reflection.jpg">

## After the dust has settled...

The writing of this essay marks the end of one of the most involved courses I have taken so far in computer science: ICS 314, Software Engineering. It feels like just yesterday that we were just learning how to navigate the course's website. But now, I have experienced an entirely new programming language and tech stack, culminating in an insanely interconnected project. Along the way, we also touched upon many other topics important to software engineering. Some were very intriguing, others barely stick in my mind now. The ones I recall enjoying or using most, I will reflect on now.

## Tracking the history of progress

Configuration management is a topic that was taught early in the course. It is all about maintaining the quality and function of a given software, which is partially achieved by keeping a good record of the changes made to the software, the improvements achieved by those changes, and the opportunity to roll back changes or have multiple configurations of a given application. These are all things covered by Git and, specifically, Github. From ICS 314, I believe learning how to use Github is the single most impactful thing I have learned. So many projects, both open and closed-source, use Github as their way of managing their project, of tracking changes and auditing them before making changes official. For me personally, I could see myself using Github in order to easily work on the same project between my laptop and my more powerful desktop computer. I also think mastery of Github will be very useful as I begin making projects that will require more than just my own skill, such as games or other kinds of interactive media. After all, it would be unreasonable for one person to do the programming, art, design, and sound for a project. Github and other version control software just makes it easier to combine the work of however many people into a single, coherent package. Just don’t work directly on main, okay?

## Who put math functions into my code?

In the introductory courses to computer science at UH Manoa, we mostly worked through object-oriented programming (OOP) languages such as Java or C++, while dabbling in somewhat different languages like C or Python that still echoed some object-oriented principles. However, in ICS 314, part of the curriculum was about learning functional programming principles. Functional programming sticks to a more strict definition of what a function can do, closer to mathematical functions than anything I have seen before. They take in input and just output something, without ever changing anything. Because of the immutability of variables, we just assign new ones instead and treat assigned variables as constants. We can even use functions as the parameters for more functions, similar to function composition in math. In practice, I did not notice too many differences compared to OOP languages. However, in theory, it is very interesting and allows for less error-prone code that more resembles math, and can thus readily simulate math. I do not foresee myself using it too much, as functional programming is not at all pointer-friendly and, from what I have seen, games and graphics programs LOVE pointers. However, it is an interesting way of programming and, if I ever pivot to a more math-oriented field of computer science, I am sure it will be useful to know.

## Doing right by people through technology

The last topic in the course, which was covered very briefly, was nonetheless very interesting and particularly important to me. Software ethics is all about being a morally righteous person while developing software. After all, software usually is intended for use in society and the world as whole. Therefore, making responsible decisions and ensuring we minimize the harm caused by our software is paramount. The word “minimization” does lend itself to some wildly varying interpretations, which depend completely on one’s philosophical perspective. As I am interested in philosophy, I think considering software ethics is one of the most important things one can do as they become a professional. Personally, my views and beliefs make me wary of certain fields of computing, such as the impact of AI on people’s lives and their livelihoods, or the use of computer vision for… less than savory ends. While I find those topics to be very interesting, exercising my views on software ethics will significantly impact which jobs and careers I consider and which ones I do not in those fields. And while I’m working on a project, it impacts how I achieve my particular design goals. Even if choosing the more morally correct path might take more time or lock me out of getting more money, I will continue to consider software ethics as I go further in my career. After all, should we not strive to make the world better for all?

## Conclusion

There are more topics that ICS 314 taught about, but once again, these topics seemed to me to have enough meat to talk about. But more than that, they all connect to things I believe all computer science classes should do. They should teach the ways programs are actually made in real life. They should teach a different way of looking at programs. But most importantly, they should teach about how our work affects the world around us. Computer science is a key part of the future of this world. The billions of people who live on this little rock we call home will have their lives determined by how the little rocks we have etched nanometer-sized patterns into will be used. And, ultimately, it is up to us to use them well.
